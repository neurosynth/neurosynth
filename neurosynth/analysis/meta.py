
import numpy as np
from neurosynth.base import imageutils
import stats
from scipy import sparse
from scipy.stats import norm


def analyze_features(dataset, features, image_type=None, threshold=0.001, q=0.05, save=None):
  """ Generate meta-analysis images for a set of features. 

  Args:
    dataset: A Dataset instance containing feature and activation data.
    features: A list of named features to generate meta-analysis maps for.
    image_type: The type of image to return. Specify one of the extensions 
      generated by the MetaAnalysis procedure--e.g., pSgA_z, pAgS, etc. By 
      default, will use pSgA_z (i.e., z-scores reflecting the probability 
      that a Mappable has a feature given that activation is present). If 
      None, set to pSgA_z.
    threshold: The threshold for determining whether or not a Mappable has 
      a feature. By default, this is 0.001, which is only sensible in the 
      case of term-based features (so be sure to specify it for other kinds).
    q: The FDR rate to use for multiple comparisons correction (default = 0.05).
    save: An optional path to save all meta-analysis images to. Images will be 
      prepended with the entire path plus the feature name; e.g., passing 
      save='test' would result in images called "test_feature1_*" for 
      a feature named feature1. If none, returns all the data as a matrix.

  Returns:
    If save is None, an n_voxels x n_features 2D numpy array.
  """
  if image_type is None:
    image_type = 'pSgA_z'
  if save is None:
    result = np.zeros((dataset.volume.num_vox_in_mask, len(features)))

  for i, f in enumerate(features):
    ids = dataset.get_ids_by_features(f, threshold=threshold)
    ma = MetaAnalysis(dataset, ids, q=q)
    if save is None:
      result[:,i] = ma.images[image_type]
    else:
      ma.save_results('%s_%s', (save, f))
  return result


class MetaAnalysis:

  """ Meta-analysis of a Dataset. Currently contrasts two subsets of 
  studies within a Dataset and saves a bunch of statistical images.
  Only one list of study IDs (ids) needs to be passed; the Universe will
  be bisected into studies that are and are not included in the 
  list, and the contrast is then performed across these two groups.
  If a seond optional second study list is provided (ids2), the Dataset 
  is first constrained to the union of ids1 and ids2, and the standard 
  contrast is then performed."""

  # DESPERATELY NEEDS REFACTORING!!!

  def __init__(self, dataset, ids, ids2=None, **kwargs):

    """ Initiaize a new MetaAnalysis instance and run an analysis.
    Args:
      dataset: A Dataset instance.
      ids: A list of Mappable IDs to include in the meta-analysis.
      ids2: Optional second list of Mappable IDs. If passed, the set of studies will 
        be restricted to the union of ids and ids2 before performing the meta-analysis.
        This is useful for meta-analytic contrasts, as the resulting images will in 
        effect identify regions that are reported/activated more frequently in one 
        list than in the other.
      kwargs: Additional optional arguments. Currently implemented:
        q: The FDR threshold to use when correcting for multiple comparisons. Set to 
          .01 by default.
    """

    self.dataset = dataset
    mt = dataset.image_table
    self.selected_ids = list(set(mt.ids) & set(ids))
    self.selected_id_indices = np.in1d(mt.ids, ids)

    # Calculate different count variables
    # print "Calculating counts..."
    n_mappables = len(mt.ids)
    n_selected = len(self.selected_ids)
    n_unselected = n_mappables - n_selected
    
    # If ids2 is provided, we only use mappables explicitly in either ids or ids2.
    # Otherwise, all mappables not in the ids list are used as the control condition.
    unselected_id_indices = ~self.selected_id_indices if ids2 == None else np.in1d(mt.ids, ids2)
    
    n_selected_active_voxels = mt.data.dot(self.selected_id_indices)
    n_unselected_active_voxels = mt.data.dot(unselected_id_indices)

    # Nomenclature for variables below: p = probability, S = selected, g = given, 
    # U = unselected, A = activation. So, e.g., pAgS = p(A|S) = probability of activation 
    # in voxel given that the mappable is selected (i.e., is included in the ids list 
    # passed to the constructor).
    pS = (n_selected+1.0)/(n_mappables+2)

    # Conditional probabilities, with Laplace smoothing
    # print "Calculating conditional probabilities..."
    # pA = np.asarray(sparse.spmatrix.mean(mt.data, 1)) + 1.0/n_mappables
    pA = (n_selected_active_voxels+1.0) / (n_mappables+2)
    pAgS = (n_selected_active_voxels+1.0)/(n_selected+2)
    pAgU = (n_unselected_active_voxels+1.0)/(n_unselected+2)
    pSgA = pAgS * pS / pA
    
    # Recompute conditionals with uniform prior
    # print "Recomputing with uniform priors..."
    prior_pS = kwargs.get('prior', 0.5)
    pAgS_unif = prior_pS * pAgS + (1-prior_pS) * pAgU
    pSgA_unif = pAgS * prior_pS / pAgS_unif

    # Set voxel-wise FDR to .05 unless explicitly specified 
    q = kwargs.get('q', 0.05)

    # One-way chi-square test for consistency of activation
    p_vals = stats.one_way(np.squeeze(n_selected_active_voxels), n_selected)
    p_vals[p_vals < 1e-240] = 1e-240  # prevents overflow due to loss of precision
    z_sign = np.sign(n_selected_active_voxels - np.mean(n_selected_active_voxels)).ravel()
    pAgS_z = np.abs(norm.ppf(p_vals/2)) * z_sign
    
    fdr_thresh = stats.fdr(p_vals, q)
    pAgS_z_FDR = imageutils.threshold_img(pAgS_z, fdr_thresh, p_vals, mask_out='above')
    

    # Two-way chi-square for specificity of activation
    cells = np.squeeze(np.array([[n_selected_active_voxels, n_unselected_active_voxels],
      [n_selected-n_selected_active_voxels, n_unselected-n_unselected_active_voxels]]).T)

    p_vals = stats.two_way(cells)
    p_vals[p_vals < 1e-240] = 1e-240  # prevents overflow
    z_sign = np.sign(pAgS - pAgU).ravel()
    pSgA_z = np.abs(norm.ppf(p_vals/2)) * z_sign
    fdr_thresh = stats.fdr(p_vals, q)
    pSgA_z_FDR = imageutils.threshold_img(pSgA_z, fdr_thresh, p_vals, mask_out='above')

    # Retain any images we may want to save or access later
    self.images = { 'pAgS': pAgS,
            'pSgA': pSgA,
            'pAgS_unif': pAgS_unif,
            'pSgA_unif': pSgA_unif,
            'pAgS_z': pAgS_z,
            'pSgA_z': pSgA_z,
            ('pAgS_z_FDR_%s' % q): pAgS_z_FDR,
            ('pSgA_z_FDR_%s' % q): pSgA_z_FDR }


  def save_results(self, outroot, image_list=None):
    """ Write out any images generated by the meta-analysis. The outroot argument is prepended 
    to all file names. Optionally, a restricted list of images to save can be passed; otherwise, 
    all images currently stored in self.images will be saved. """
    print "Saving results..."
    if image_list == None: image_list = self.images.keys()
    for suffix, img in self.images.items():
      if suffix in image_list:
        imageutils.save_img(img, '%s_%s.nii.gz' % (outroot, suffix), self.dataset.volume)
